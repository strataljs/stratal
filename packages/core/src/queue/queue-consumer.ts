/**
 * Queue message structure
 *
 * All messages dispatched to queues follow this structure.
 * The `id` and `timestamp` are auto-generated by QueueSender.
 */
export interface QueueMessage<T = unknown> {
  /** Unique message identifier (UUID) */
  id: string
  /** Timestamp when message was dispatched (milliseconds since epoch) */
  timestamp: number
  /** Message type for routing to consumers */
  type: string
  /** Optional tenant ID for multi-tenant context */
  tenantId?: string
  /** Message payload */
  payload: T
  /** Optional metadata including locale for i18n */
  metadata?: {
    locale?: string
    [key: string]: unknown
  }
}

/**
 * Queue consumer interface
 *
 * Consumers handle messages based on their `messageTypes` declaration.
 * A consumer receives messages of the declared types from ANY queue.
 *
 * @example
 * ```typescript
 * @Transient()
 * export class EmailConsumer implements IQueueConsumer<SendEmailInput> {
 *   readonly messageTypes = ['email.send', 'email.batch.send']
 *
 *   async handle(message: QueueMessage<SendEmailInput>): Promise<void> {
 *     // Process email...
 *   }
 * }
 * ```
 */
export interface IQueueConsumer<T = unknown> {
  /**
   * Message types this consumer handles.
   *
   * The consumer receives messages matching these types from ANY queue.
   * Use '*' to match all message types (wildcard consumer).
   */
  readonly messageTypes: string[]

  /**
   * Handle an incoming message
   *
   * @param message - The queue message to process
   */
  handle(message: QueueMessage<T>): Promise<void>

  /**
   * Optional error handler for failed message processing
   *
   * @param error - The error that occurred
   * @param message - The message that failed to process
   */
  onError?(error: Error, message: QueueMessage<T>): Promise<void>
}

